
local TweenService = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local key = "1"
local discordLink = "https://discord.gg/EXK4dQxJBv"
local scriptToLoad = [[
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Lighting = game:GetService("Lighting")
local player = Players.LocalPlayer
local random = Random.new()

--// Configuration
local DEBUG = false
local tpAmt
local void = CFrame.new(0, -3.4028234663852886e+38, 0)
local teleporting

local function DebugInfo(mode, content, value)
    if not DEBUG then return end
    if mode == "warn" then
        warn("[ArbixTP DEBUG]:", content, value or "")
    elseif mode == "print" then
        print("[ArbixTP DEBUG]:", content, value or "")
    else
        warn("[ArbixTP DEBUG]: Invalid debug type.")
    end
end

--// Player & Character setup
local backpack = player:WaitForChild("Backpack")
local char, humanoid, hrp

local function GetCharacter()
    return player.Character or player.CharacterAdded:Wait()
end

local function SetupCharacter()
    char = GetCharacter()
    humanoid = char:WaitForChild("Humanoid")
    hrp = char:WaitForChild("HumanoidRootPart")
    backpack = player:WaitForChild("Backpack")
    DebugInfo("print", "Character setup completed for", player.Name)
end

SetupCharacter()

player.CharacterAdded:Connect(function()
    SetupCharacter()
end)

--// Calculate tpAmt from Latency
task.spawn(function()
    while true do
        local ping = player:GetNetworkPing() * 1000
        tpAmt = math.clamp(math.floor(ping * 0.8), 10, 150)
        if DEBUG then
            DebugInfo("print", "Ping: " .. math.floor(ping) .. "ms | tpAmt:", tpAmt)
        end
        RunService.Heartbeat:Wait()
    end
end)

local function TP(position)
    if not teleporting then
        teleporting = true
        if typeof(position) == "CFrame" then
            hrp.CFrame = position + Vector3.new(
                random:NextNumber(-0.0001, 0.0001),
                random:NextNumber(-0.0001, 0.0001),
                random:NextNumber(-0.0001, 0.0001)
            )
            RunService.Heartbeat:Wait()
            teleporting = false
        end
    else
        DebugInfo("warn", "You are already teleporting", "teleporting")
    end
end

local function FindDelivery()
    local plots = workspace:FindFirstChild("Plots")
    if not plots then
        DebugInfo("warn", "Plots folder not found in workspace", nil)
        return
    end
    for _, plot in pairs(plots:GetChildren()) do
        local sign = plot:FindFirstChild("PlotSign")
        if sign then
            local yourBase = sign:FindFirstChild("YourBase")
            if yourBase and yourBase.Enabled then
                local hitbox = plot:FindFirstChild("DeliveryHitbox")
                if hitbox then return hitbox end
            end
        end
    end
    DebugInfo("warn", "No valid DeliveryHitbox found", nil)
end

local function DeliverBrainrot(statusLabel)
    -- Verificar si el personaje existe
    if not char or not hrp then
        statusLabel.Text = "Error: Character not loaded"
        statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
        task.wait(2)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 1}):Play()
        return
    end

    local function attemptDelivery()
        local hitbox = FindDelivery()
        if not hitbox then
            statusLabel.Text = "Error: DeliveryHitbox not found"
            statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)
            TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
            task.wait(2)
            TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 1}):Play()
            return false
        end

        DebugInfo("print", "DeliveryHitbox successfully found", hitbox)

        -- Mejorar la posici√≥n objetivo con offset aleatorio
        local randomOffset = Vector3.new(
            random:NextNumber(-2, 2),
            random:NextNumber(-3, -1),
            random:NextNumber(-2, 2)
        )
        local target = hitbox.CFrame * CFrame.new(randomOffset)
        
        -- Fase 1: Movimiento stealth gradual
        statusLabel.Text = "ü¶ã Phase 1: Stealth movement..."
        statusLabel.TextColor3 = Color3.fromRGB(255, 165, 0)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
        
        local currentPos = hrp.Position
        local targetPos = target.Position
        local distance = (currentPos - targetPos).Magnitude
        local steps = math.max(60, math.floor(distance / 8))
        
        for i = 1, steps do
            local progress = i / steps
            local curvedProgress = progress * progress * (3 - 2 * progress) -- Smooth curve
            
            local newPos = currentPos:Lerp(targetPos, curvedProgress)
            newPos += Vector3.new(
                random:NextNumber(-0.3, 0.3),
                random:NextNumber(-0.3, 0.3),
                random:NextNumber(-0.3, 0.3)
            )
            
            hrp.CFrame = CFrame.new(newPos) * (hrp.CFrame - hrp.Position)
            
            if i % 15 == 0 then
                statusLabel.Text = "ü¶ã Phase 1: " .. math.floor(progress * 100) .. "%"
                task.wait(random:NextNumber(0.02, 0.04))
            else
                task.wait(random:NextNumber(0.01, 0.02))
            end
        end
        
        -- Fase 2: Ajuste de precisi√≥n para entrega
        statusLabel.Text = "üéØ Phase 2: Delivery precision..."
        statusLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
        
        for i = 1, 20 do
            local precisionTarget = target * CFrame.new(
                random:NextNumber(-1.5, 1.5),
                random:NextNumber(-1, 0.5),
                random:NextNumber(-1.5, 1.5)
            )
            
            hrp.CFrame = precisionTarget
            task.wait(random:NextNumber(0.03, 0.08))
            
            if i % 5 == 0 then
                statusLabel.Text = "üéØ Phase 2: " .. math.floor((i/20) * 100) .. "%"
            end
        end
        
        -- Verificaci√≥n final con tolerancia
        task.wait(0.3)
        local distance = (hrp.Position - target.Position).Magnitude
        
        if distance <= 30 then
            return true, target
        else
            -- Intentar ajuste final si est√° cerca
            if distance <= 50 then
                statusLabel.Text = "üîß Final adjustment..."
                statusLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
                TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
                
                for i = 1, 10 do
                    hrp.CFrame = target
                    task.wait(random:NextNumber(0.02, 0.05))
                end
                
                local finalDistance = (hrp.Position - target.Position).Magnitude
                return finalDistance <= 35, target
            end
        end
        
        return false, target
    end

    -- Funci√≥n para verificar si el brainrot fue entregado
    local function checkDeliverySuccess()
        -- Esperar un poco para que el juego procese la entrega
        task.wait(0.5)
        
        -- Verificar si hay alg√∫n indicador de entrega exitosa
        local deliverySuccess = false
        
        -- Opci√≥n 1: Verificar si el hitbox sigue activo (si no, significa que se entreg√≥)
        local hitbox = FindDelivery()
        if not hitbox then
            deliverySuccess = true
            DebugInfo("print", "Delivery success detected: Hitbox disappeared", "")
            return deliverySuccess
        end
        
        -- Opci√≥n 2: Verificar la distancia al hitbox (m√°s permisivo)
        if hitbox then
            local distance = (hrp.Position - hitbox.Position).Magnitude
            if distance > 30 then -- Reducido de 50 a 30 studs
                deliverySuccess = true
                DebugInfo("print", "Delivery success detected: Player far from hitbox", distance)
                return deliverySuccess
            end
        end
        
        -- Opci√≥n 3: Verificar si el jugador est√° en una posici√≥n v√°lida para entrega
        if hitbox then
            local distance = (hrp.Position - hitbox.Position).Magnitude
            -- Si est√° muy cerca del hitbox (menos de 10 studs), probablemente ya se entreg√≥
            if distance <= 10 then
                -- Esperar un poco m√°s y verificar si el hitbox sigue ah√≠
                task.wait(0.5)
                local newHitbox = FindDelivery()
                if not newHitbox or (hrp.Position - newHitbox.Position).Magnitude > 15 then
                    deliverySuccess = true
                    DebugInfo("print", "Delivery success detected: Hitbox disappeared after close proximity", "")
                    return deliverySuccess
                end
            end
        end
        
        -- Opci√≥n 4: Verificar si hay alg√∫n cambio en el inventario o stats del jugador
        -- (Esto depender√≠a de c√≥mo el juego maneja las entregas)
        
        DebugInfo("print", "Delivery check result", deliverySuccess)
        return deliverySuccess
    end

    -- Sistema de reintentos autom√°ticos
    local maxDeliveryAttempts = 3 -- Reducido de 5 a 3 para evitar spam
    local currentAttempt = 1
    local deliverySuccessful = false

    while currentAttempt <= maxDeliveryAttempts and not deliverySuccessful do
        statusLabel.Text = "üîÑ Delivery Attempt " .. currentAttempt .. "/" .. maxDeliveryAttempts
        statusLabel.TextColor3 = Color3.fromRGB(255, 165, 0)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
        task.wait(1)
        
        local teleportSuccess, target = attemptDelivery()
        
        if teleportSuccess then
            statusLabel.Text = "‚úÖ Teleport successful! Checking delivery..."
            statusLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
            TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
            
            -- Verificar si la entrega fue exitosa
            deliverySuccessful = checkDeliverySuccess()
            
            if deliverySuccessful then
                statusLabel.Text = "üéâ Brainrot delivered successfully!"
                statusLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
                TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
                task.wait(3)
                TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 1}):Play()
                return
            else
                -- Verificaci√≥n adicional: si el teleport fue exitoso y estamos muy cerca, probablemente se entreg√≥
                local finalDistance = (hrp.Position - target.Position).Magnitude
                if finalDistance <= 15 then
                    statusLabel.Text = "üéâ Brainrot likely delivered! (Close proximity)"
                    statusLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
                    TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
                    task.wait(3)
                    TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 1}):Play()
                    return
                else
                    statusLabel.Text = "‚ö†Ô∏è Teleport successful but delivery failed. Retrying..."
                    statusLabel.TextColor3 = Color3.fromRGB(255, 165, 0)
                    TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
                    task.wait(2)
                end
            end
        else
            statusLabel.Text = "‚ùå Teleport failed. Retrying..."
            statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)
            TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
            task.wait(2)
        end
        
        currentAttempt += 1
        
        -- Peque√±a pausa entre intentos
        if currentAttempt <= maxDeliveryAttempts then
            task.wait(1)
        end
    end
    
    -- Si llegamos aqu√≠, todos los intentos fallaron
    if not deliverySuccessful then
        statusLabel.Text = "üíÄ All delivery attempts failed after " .. maxDeliveryAttempts .. " tries"
        statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
        task.wait(3)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 1}):Play()
    end
end

local function TPNearestBase(statusLabel)
    -- Verificar si el personaje existe
    if not char or not hrp then
        statusLabel.Text = "Error: Character not loaded"
        statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
        task.wait(2)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 1}):Play()
        return
    end

    local plotsFolder = workspace:FindFirstChild("Plots")
    if not plotsFolder then
        DebugInfo("warn", "Missing folder", "Plots")
        statusLabel.Text = "Error: Plots folder not found"
        statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
        task.wait(2)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 1}):Play()
        return
    end

    statusLabel.Text = "üîç Searching for nearest base..."
    statusLabel.TextColor3 = Color3.fromRGB(255, 165, 0)
    TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()

    local closestBrainrot = nil
    local shortestDistance = math.huge
    local baseOwner = nil
    local baseName = nil

    -- B√∫squeda mejorada con m√°s informaci√≥n
    for _, plot in pairs(plotsFolder:GetChildren()) do
        local plotSign = plot:FindFirstChild("PlotSign")
        if plotSign then
            local surfaceGui = plotSign:FindFirstChild("SurfaceGui")
            if surfaceGui then
                local frame = surfaceGui:FindFirstChild("Frame")
                if frame then
                    local textLabel = frame:FindFirstChild("TextLabel")
                    if textLabel and textLabel.ContentText and textLabel.ContentText ~= "Empty Base" then
                        local yourBase = plotSign:FindFirstChild("YourBase")
                        if yourBase and not yourBase.Enabled then
                            local podiums = plot:FindFirstChild("AnimalPodiums")
                            if podiums then
                                for _, brainrot in pairs(podiums:GetChildren()) do
                                    if brainrot:IsA("Model") and brainrot:FindFirstChild("Base") then
                                        local base = brainrot:FindFirstChild("Base")
                                        local spawn = base:FindFirstChild("Spawn")
                                        if spawn then
                                            local distance = (spawn.Position - hrp.Position).Magnitude
                                            if distance < shortestDistance then
                                                shortestDistance = distance
                                                closestBrainrot = spawn
                                                baseOwner = textLabel.ContentText
                                                baseName = brainrot.Name
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    if not closestBrainrot then
        DebugInfo("warn", "No valid podium found", nil)
        statusLabel.Text = "‚ùå Error: No valid base found"
        statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
        task.wait(2)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 1}):Play()
        return
    end

    DebugInfo("print", "Nearest podium found", closestBrainrot)
    
    -- Mostrar informaci√≥n del base encontrado
    local baseInfo = baseOwner and (" (" .. baseOwner .. ")") or ""
    statusLabel.Text = "üéØ Found base: " .. (baseName or "Unknown") .. baseInfo .. " - Distance: " .. math.floor(shortestDistance) .. " studs"
    statusLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
    TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
    task.wait(1.5)

    -- Funci√≥n de teleportaci√≥n stealth mejorada
    local function executeStealthTeleport()
        local target = closestBrainrot.CFrame * CFrame.new(
            random:NextNumber(-2, 2),
            random:NextNumber(2, 4),
            random:NextNumber(-2, 2)
        )
        
        -- Fase 1: Movimiento gradual y sutil
        statusLabel.Text = "ü¶ã Phase 1: Stealth movement..."
        statusLabel.TextColor3 = Color3.fromRGB(255, 165, 0)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
        
        local currentPos = hrp.Position
        local targetPos = target.Position
        local steps = math.max(50, math.floor(shortestDistance / 10))
        
        for i = 1, steps do
            local progress = i / steps
            local curvedProgress = progress * progress * (3 - 2 * progress) -- Smooth curve
            
            local newPos = currentPos:Lerp(targetPos, curvedProgress)
            newPos += Vector3.new(
                random:NextNumber(-0.5, 0.5),
                random:NextNumber(-0.5, 0.5),
                random:NextNumber(-0.5, 0.5)
            )
            
            hrp.CFrame = CFrame.new(newPos) * (hrp.CFrame - hrp.Position)
            
            if i % 10 == 0 then
                statusLabel.Text = "ü¶ã Phase 1: " .. math.floor(progress * 100) .. "%"
                task.wait(random:NextNumber(0.02, 0.05))
            else
                task.wait(random:NextNumber(0.01, 0.03))
            end
        end
        
        -- Fase 2: Ajuste de precisi√≥n con pausas
        statusLabel.Text = "üéØ Phase 2: Precision adjustment..."
        statusLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
        
        for i = 1, 15 do
            local precisionTarget = target * CFrame.new(
                random:NextNumber(-1, 1),
                random:NextNumber(0, 1),
                random:NextNumber(-1, 1)
            )
            
            hrp.CFrame = precisionTarget
            task.wait(random:NextNumber(0.05, 0.1))
            
            if i % 5 == 0 then
                statusLabel.Text = "üéØ Phase 2: " .. math.floor((i/15) * 100) .. "%"
            end
        end
        
        return target
    end

    -- Sistema de reintentos con pausas
    local maxAttempts = 2
    local currentAttempt = 1
    local teleportSuccessful = false
    local finalTarget = nil

    while currentAttempt <= maxAttempts and not teleportSuccessful do
        statusLabel.Text = "üîÑ Stealth Attempt " .. currentAttempt .. "/" .. maxAttempts
        statusLabel.TextColor3 = Color3.fromRGB(255, 165, 0)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
        task.wait(1)
        
        finalTarget = executeStealthTeleport()
        
        -- Verificaci√≥n de √©xito con tolerancia
        task.wait(0.5)
        local distance = (hrp.Position - finalTarget.Position).Magnitude
        
        if distance <= 35 then
            teleportSuccessful = true
            statusLabel.Text = "‚úÖ Stealth teleport successful! Distance: " .. math.floor(distance) .. " studs"
            statusLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
            TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
            task.wait(3)
            TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 1}):Play()
            return
        else
            if currentAttempt < maxAttempts then
                statusLabel.Text = "‚ö†Ô∏è Stealth failed (Distance: " .. math.floor(distance) .. "). Retrying..."
                statusLabel.TextColor3 = Color3.fromRGB(255, 165, 0)
                TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
                task.wait(2)
            end
        end
        
        currentAttempt += 1
    end
    
    -- Si llegamos aqu√≠, todos los intentos fallaron
    if not teleportSuccessful then
        local finalDistance = (hrp.Position - finalTarget.Position).Magnitude
        statusLabel.Text = "üíÄ Stealth attempts failed. Final distance: " .. math.floor(finalDistance) .. " studs"
        statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
        task.wait(3)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 1}):Play()
    end
end

local function TweenSteal(statusLabel)
    local STEALTH_STEPS = 70
    local VOID_CFRAME = CFrame.new(0, -3e40, 0)
    local JITTER_RANGE = 0.0001

    local function executeStealthMovement(targetCF, steps)
        if not hrp or typeof(targetCF) ~= "CFrame" then
            DebugInfo("warn", "Invalid HRP or target CFrame", nil)
            return false
        end
        
        local currentPos = hrp.Position
        local targetPos = targetCF.Position
        local distance = (currentPos - targetPos).Magnitude
        local adjustedSteps = math.max(steps, math.floor(distance / 5))

        statusLabel.Text = "ü¶ã Stealth movement in progress..."
        statusLabel.TextColor3 = Color3.fromRGB(255, 165, 0)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()

        for i = 1, adjustedSteps do
            local progress = i / adjustedSteps
            local curvedProgress = progress * progress * (3 - 2 * progress)
            
            local newPos = currentPos:Lerp(targetPos, curvedProgress)
            newPos += Vector3.new(
                random:NextNumber(-JITTER_RANGE, JITTER_RANGE),
                random:NextNumber(-JITTER_RANGE, JITTER_RANGE),
                random:NextNumber(-JITTER_RANGE, JITTER_RANGE)
            )

            hrp.CFrame = CFrame.new(newPos) * (hrp.CFrame - hrp.Position)
            
            if i % 10 == 0 then
                statusLabel.Text = "ü¶ã Stealth: " .. math.floor(progress * 100) .. "%"
                task.wait(random:NextNumber(0.02, 0.04))
            else
                task.wait(random:NextNumber(0.01, 0.02))
            end
        end
        return true
    end

    local function findDeliverySpot()
        for _, v in ipairs(workspace.Plots:GetDescendants()) do
            if v.Name == "DeliveryHitbox" and v.Parent:FindFirstChild("PlotSign") then
                if v.Parent.PlotSign:FindFirstChild("YourBase") and v.Parent.PlotSign.YourBase.Enabled then
                    return v
                end
            end
        end
        DebugInfo("warn", "No valid DeliveryHitbox found for TweenSteal", nil)
        return nil
    end

    local delivery = findDeliverySpot()
    if not delivery then
        statusLabel.Text = "Error: DeliveryHitbox not found"
        statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
        task.wait(2)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 1}):Play()
        return
    end

    DebugInfo("print", "DeliveryHitbox found for TweenSteal", delivery)

    local targetPos = delivery.CFrame * CFrame.new(
        random:NextNumber(-2, 2),
        random:NextNumber(-3, -1),
        random:NextNumber(-2, 2)
    )
    
    -- Ejecutar movimiento stealth principal
    local success = executeStealthMovement(targetPos, STEALTH_STEPS)
    
    if success then
        -- Ajuste de precisi√≥n final
        statusLabel.Text = "üéØ Final precision adjustment..."
        statusLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
        TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
        
        for i = 1, 15 do
            local precisionTarget = targetPos * CFrame.new(
                random:NextNumber(-1, 1),
                random:NextNumber(-0.5, 0.5),
                random:NextNumber(-1, 1)
            )
            
            hrp.CFrame = precisionTarget
            task.wait(random:NextNumber(0.03, 0.06))
        end
    end

    task.wait(0.5)
    local distance = (hrp.Position - targetPos.Position).Magnitude
    if distance <= 35 then
        DebugInfo("print", "TweenSteal succeeded", distance)
        statusLabel.Text = "‚úÖ Stealth TweenSteal Succeeded!"
        statusLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
    else
        DebugInfo("warn", "TweenSteal failed", distance)
        statusLabel.Text = "‚ùå Stealth TweenSteal Failed: Too far (" .. math.floor(distance) .. ")"
        statusLabel.TextColor3 = Color3.fromRGB(255, 80, 80)
    end
    TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
    task.wait(2)
    TweenService:Create(statusLabel, TweenInfo.new(0.3), {TextTransparency = 1}):Play()
end

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "ArbixTPGui"
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.IgnoreGuiInset = true
ScreenGui.DisplayOrder = 999
ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
DebugInfo("print", "ArbixTPGui created", ScreenGui.Name)

local Blur = Instance.new("BlurEffect")
Blur.Name = "ArbixTPBlur"
Blur.Size = 0
Blur.Parent = workspace
DebugInfo("print", "ArbixTPBlur created", Blur.Name)

local Frame = Instance.new("Frame")
Frame.Parent = ScreenGui
Frame.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
Frame.BorderSizePixel = 0
Frame.AnchorPoint = Vector2.new(0.5, 0.5)
Frame.Position = UDim2.new(0.5, 0, 0.5, 0)
Frame.Size = UDim2.new(0, 0, 0, 0)
Frame.ClipsDescendants = true
Frame.BackgroundTransparency = 1

local Gradient = Instance.new("UIGradient")
Gradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 25, 35)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(20, 20, 30)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(15, 15, 25))
})
Gradient.Rotation = 45
Gradient.Parent = Frame

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 16)
UICorner.Parent = Frame

local DropShadow = Instance.new("ImageLabel")
DropShadow.Name = "DropShadow"
DropShadow.Parent = Frame
DropShadow.AnchorPoint = Vector2.new(0.5, 0.5)
DropShadow.BackgroundTransparency = 1
DropShadow.Position = UDim2.new(0.5, 0, 0.5, 8)
DropShadow.Size = UDim2.new(1, 24, 1, 24)
DropShadow.Image = "rbxassetid://6014261993"
DropShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
DropShadow.ImageTransparency = 0.6
DropShadow.ScaleType = Enum.ScaleType.Slice
DropShadow.SliceCenter = Rect.new(10, 10, 118, 118)
DropShadow.ZIndex = -1
DropShadow.Visible = false

local TitleBar = Instance.new("Frame")
TitleBar.Name = "TitleBar"
TitleBar.Parent = Frame
TitleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
TitleBar.BorderSizePixel = 0
TitleBar.Size = UDim2.new(1, 0, 0, 40)
TitleBar.ZIndex = 2

local TitleBarGradient = Instance.new("UIGradient")
TitleBarGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 45)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 20, 30))
})
TitleBarGradient.Parent = TitleBar

local TitleBarCorner = Instance.new("UICorner")
TitleBarCorner.CornerRadius = UDim.new(0, 16)
TitleBarCorner.Parent = TitleBar

local TitleLabel = Instance.new("TextLabel")
TitleLabel.Name = "Title"
TitleLabel.Parent = TitleBar
TitleLabel.BackgroundTransparency = 1
TitleLabel.Size = UDim2.new(1, -80, 1, 0)
TitleLabel.Position = UDim2.new(0, 15, 0, 0)
TitleLabel.Font = Enum.Font.GothamBlack
TitleLabel.Text = "Arbix Hub Premium+ v2"
TitleLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
TitleLabel.TextSize = 18
TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
TitleLabel.TextTransparency = 1

local ButtonFrame = Instance.new("Frame")
ButtonFrame.Parent = TitleBar
ButtonFrame.BackgroundTransparency = 1
ButtonFrame.Size = UDim2.new(0, 80, 1, 0)
ButtonFrame.Position = UDim2.new(1, -80, 0, 0)

local MinimizeButton = Instance.new("TextButton")
MinimizeButton.Name = "MinimizeButton"
MinimizeButton.Parent = ButtonFrame
MinimizeButton.AnchorPoint = Vector2.new(0.5, 0.5)
MinimizeButton.BackgroundTransparency = 1
MinimizeButton.Position = UDim2.new(0.65, 0, 0.5, 0)
MinimizeButton.Size = UDim2.new(0, 24, 0, 24)
MinimizeButton.Font = Enum.Font.GothamBold
MinimizeButton.Text = "‚Äî"
MinimizeButton.TextColor3 = Color3.fromRGB(255, 215, 0)
MinimizeButton.TextSize = 16
MinimizeButton.TextTransparency = 1

local CloseButton = Instance.new("TextButton")
CloseButton.Name = "CloseButton"
CloseButton.Parent = ButtonFrame
CloseButton.AnchorPoint = Vector2.new(0.5, 0.5)
CloseButton.BackgroundTransparency = 1
CloseButton.Position = UDim2.new(0.85, 0, 0.5, 0)
CloseButton.Size = UDim2.new(0, 24, 0, 24)
CloseButton.Font = Enum.Font.GothamBold
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.fromRGB(255, 100, 100)
CloseButton.TextSize = 16
CloseButton.TextTransparency = 1

local Content = Instance.new("Frame")
Content.Name = "Content"
Content.Parent = Frame
Content.BackgroundTransparency = 1
Content.Position = UDim2.new(0, 0, 0, 40)
Content.Size = UDim2.new(1, 0, 1, -40)

local DeliveryButton = Instance.new("TextButton")
DeliveryButton.Name = "DeliveryButton"
DeliveryButton.Parent = Content
DeliveryButton.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
DeliveryButton.TextColor3 = Color3.fromRGB(255, 255, 255)
DeliveryButton.Position = UDim2.new(0.1, 0, 0.15, 0)
DeliveryButton.Size = UDim2.new(0.8, 0, 0, 50)
DeliveryButton.Font = Enum.Font.GothamSemibold
DeliveryButton.Text = "üöÄ Teleport to Delivery"
DeliveryButton.TextSize = 16
DeliveryButton.TextWrapped = true
DeliveryButton.TextTransparency = 1
DeliveryButton.AutoButtonColor = false

local UICorner_Delivery = Instance.new("UICorner")
UICorner_Delivery.CornerRadius = UDim.new(0, 12)
UICorner_Delivery.Parent = DeliveryButton

local DeliveryStroke = Instance.new("UIStroke")
DeliveryStroke.Parent = DeliveryButton
DeliveryStroke.Color = Color3.fromRGB(186, 85, 211)
DeliveryStroke.Thickness = 2
DeliveryStroke.Transparency = 0.5

local BaseButton = Instance.new("TextButton")
BaseButton.Name = "BaseButton"
BaseButton.Parent = Content
BaseButton.BackgroundColor3 = Color3.fromRGB(34, 139, 34)
BaseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
BaseButton.Position = UDim2.new(0.1, 0, 0.35, 0)
BaseButton.Size = UDim2.new(0.8, 0, 0, 50)
BaseButton.Font = Enum.Font.GothamSemibold
BaseButton.Text = "üè† Teleport to Base"
BaseButton.TextSize = 16
BaseButton.TextWrapped = true
BaseButton.TextTransparency = 1
BaseButton.AutoButtonColor = false

local UICorner_Base = Instance.new("UICorner")
UICorner_Base.CornerRadius = UDim.new(0, 12)
UICorner_Base.Parent = BaseButton

local BaseStroke = Instance.new("UIStroke")
BaseStroke.Parent = BaseButton
BaseStroke.Color = Color3.fromRGB(50, 205, 50)
BaseStroke.Thickness = 2
BaseStroke.Transparency = 0.5

local TweenStealButton = Instance.new("TextButton")
TweenStealButton.Name = "TweenStealButton"
TweenStealButton.Parent = Content
TweenStealButton.BackgroundColor3 = Color3.fromRGB(220, 20, 60)
TweenStealButton.TextColor3 = Color3.fromRGB(255, 255, 255)
TweenStealButton.Position = UDim2.new(0.1, 0, 0.55, 0)
TweenStealButton.Size = UDim2.new(0.8, 0, 0, 50)
TweenStealButton.Font = Enum.Font.GothamSemibold
TweenStealButton.Text = "‚ö° Steal Teleport"
TweenStealButton.TextSize = 16
TweenStealButton.TextWrapped = true
TweenStealButton.TextTransparency = 1
TweenStealButton.AutoButtonColor = false

local UICorner_TweenSteal = Instance.new("UICorner")
UICorner_TweenSteal.CornerRadius = UDim.new(0, 12)
UICorner_TweenSteal.Parent = TweenStealButton

local TweenStealStroke = Instance.new("UIStroke")
TweenStealStroke.Parent = TweenStealButton
TweenStealStroke.Color = Color3.fromRGB(255, 69, 0)
TweenStealStroke.Thickness = 2
TweenStealStroke.Transparency = 0.5

local StatusLabel = Instance.new("TextLabel")
StatusLabel.Name = "StatusLabel"
StatusLabel.Parent = Content
StatusLabel.BackgroundTransparency = 1
StatusLabel.Size = UDim2.new(0.8, 0, 0, 30)
StatusLabel.Position = UDim2.new(0.1, 0, 0.75, 0)
StatusLabel.Font = Enum.Font.Gotham
StatusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
StatusLabel.TextSize = 14
StatusLabel.TextTransparency = 1
StatusLabel.Text = ""
StatusLabel.TextWrapped = true

local function createHoverEffect(button, stroke, originalColor, originalStrokeColor)
    button.MouseEnter:Connect(function()
        local hoverColor = Color3.fromRGB(
            math.min(originalColor.R * 255 + 30, 255),
            math.min(originalColor.G * 255 + 30, 255),
            math.min(originalColor.B * 255 + 30, 255)
        )
        TweenService:Create(button, TweenInfo.new(0.2, Enum.EasingStyle.Exponential), {
            BackgroundColor3 = hoverColor,
            TextColor3 = Color3.fromRGB(255, 255, 255)
        }):Play()
        TweenService:Create(stroke, TweenInfo.new(0.2, Enum.EasingStyle.Exponential), {
            Color = originalStrokeColor,
            Thickness = 3,
            Transparency = 0.2
        }):Play()
    end)
    button.MouseLeave:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2, Enum.EasingStyle.Exponential), {
            BackgroundColor3 = originalColor,
            TextColor3 = Color3.fromRGB(255, 255, 255)
        }):Play()
        TweenService:Create(stroke, TweenInfo.new(0.2, Enum.EasingStyle.Exponential), {
            Color = originalStrokeColor,
            Thickness = 2,
            Transparency = 0.5
        }):Play()
    end)
end

createHoverEffect(DeliveryButton, DeliveryStroke, Color3.fromRGB(138, 43, 226), Color3.fromRGB(186, 85, 211))
createHoverEffect(BaseButton, BaseStroke, Color3.fromRGB(34, 139, 34), Color3.fromRGB(50, 205, 50))
createHoverEffect(TweenStealButton, TweenStealStroke, Color3.fromRGB(220, 20, 60), Color3.fromRGB(255, 69, 0))

-- Initial animation
task.wait(0.1)
TweenService:Create(Blur, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = 15}):Play()
TweenService:Create(Frame, TweenInfo.new(0.6, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
    Size = UDim2.new(0, 450, 0, 360),
    BackgroundTransparency = 0.1,
    BackgroundColor3 = Color3.fromRGB(15, 15, 20)
}):Play()
DropShadow.Visible = true
TweenService:Create(DropShadow, TweenInfo.new(0.6), {ImageTransparency = 0.6}):Play()

task.wait(0.3)
TweenService:Create(TitleLabel, TweenInfo.new(0.4), {TextTransparency = 0}):Play()
TweenService:Create(CloseButton, TweenInfo.new(0.4), {TextTransparency = 0}):Play()
TweenService:Create(MinimizeButton, TweenInfo.new(0.4), {TextTransparency = 0}):Play()

task.wait(0.2)
TweenService:Create(DeliveryButton, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
    TextTransparency = 0,
    BackgroundTransparency = 0
}):Play()
TweenService:Create(DeliveryStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
TweenService:Create(BaseButton, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
    TextTransparency = 0,
    BackgroundTransparency = 0
}):Play()
TweenService:Create(BaseStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
TweenService:Create(TweenStealButton, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
    TextTransparency = 0,
    BackgroundTransparency = 0
}):Play()
TweenService:Create(TweenStealStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()

DeliveryButton.MouseButton1Click:Connect(function()
    DebugInfo("print", "Delivery button clicked", "")
    DeliverBrainrot(StatusLabel)
end)

BaseButton.MouseButton1Click:Connect(function()
    DebugInfo("print", "Base button clicked", "")
    TPNearestBase(StatusLabel)
end)

TweenStealButton.MouseButton1Click:Connect(function()
    DebugInfo("print", "TweenSteal button clicked", "")
    TweenSteal(StatusLabel)
end)

local isMinimized = false
local originalSize = UDim2.new(0, 450, 0, 360)
local minimizedSize = UDim2.new(0, 200, 0, 40)

MinimizeButton.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    local targetSize = isMinimized and minimizedSize or originalSize
    local contentTransparency = isMinimized and 1 or 0
    
    TweenService:Create(Frame, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
        Size = targetSize,
        BackgroundColor3 = Color3.fromRGB(15, 15, 20)
    }):Play()
    
    TweenService:Create(Content, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
        Visible = not isMinimized
    }):Play()
    
    TweenService:Create(DropShadow, TweenInfo.new(0.4), {
        ImageTransparency = 0.6,
        Visible = true
    }):Play()
    
    TweenService:Create(DeliveryButton, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
        TextTransparency = contentTransparency,
        BackgroundTransparency = contentTransparency
    }):Play()
    
    TweenService:Create(DeliveryStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
        Transparency = contentTransparency
    }):Play()
    
    TweenService:Create(BaseButton, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
        TextTransparency = contentTransparency,
        BackgroundTransparency = contentTransparency
    }):Play()
    
    TweenService:Create(BaseStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
        Transparency = contentTransparency
    }):Play()
    
    TweenService:Create(TweenStealButton, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
        TextTransparency = contentTransparency,
        BackgroundTransparency = contentTransparency
    }):Play()
    
    TweenService:Create(TweenStealStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
        Transparency = contentTransparency
    }):Play()
    
    TweenService:Create(StatusLabel, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
        TextTransparency = contentTransparency
    }):Play()
    
    MinimizeButton.Text = isMinimized and "‚ñ°" or "‚Äî"
    DebugInfo("print", "Minimize toggled", isMinimized and "Minimized" or "Restored")
end)

CloseButton.MouseButton1Click:Connect(function()
    TweenService:Create(Frame, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
        Size = UDim2.new(0, 0, 0, 0),
        BackgroundTransparency = 1
    }):Play()
    TweenService:Create(Blur, TweenInfo.new(0.4), {Size = 0}):Play()
    task.wait(0.4)
    ScreenGui:Destroy()
    Blur:Destroy()
    DebugInfo("print", "ArbixTPGui closed", "")
end)

local isGuiVisible = true
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.LeftControl then
        isGuiVisible = not isGuiVisible
        if isGuiVisible then
            TweenService:Create(Frame, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Size = isMinimized and minimizedSize or originalSize,
                BackgroundColor3 = Color3.fromRGB(15, 15, 20),
                BackgroundTransparency = 0.1
            }):Play()
            TweenService:Create(Blur, TweenInfo.new(0.4), {Size = 15}):Play()
            TweenService:Create(DropShadow, TweenInfo.new(0.4), {
                ImageTransparency = 0.6,
                Visible = true
            }):Play()
            TweenService:Create(Content, TweenInfo.new(0.4), {
                Visible = not isMinimized
            }):Play()
            if not isMinimized then
                TweenService:Create(DeliveryButton, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
                    TextTransparency = 0,
                    BackgroundTransparency = 0
                }):Play()
                TweenService:Create(DeliveryStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
                TweenService:Create(BaseButton, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
                    TextTransparency = 0,
                    BackgroundTransparency = 0
                }):Play()
                TweenService:Create(BaseStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
                TweenService:Create(TweenStealButton, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
                    TextTransparency = 0,
                    BackgroundTransparency = 0
                }):Play()
                TweenService:Create(TweenStealStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
                TweenService:Create(StatusLabel, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
            end
            DebugInfo("print", "ArbixTPGui shown", "")
        else
            TweenService:Create(Frame, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {
                Size = UDim2.new(0, 0, 0, 0),
                BackgroundTransparency = 1
            }):Play()
            TweenService:Create(Blur, TweenInfo.new(0.4), {Size = 0}):Play()
            TweenService:Create(DropShadow, TweenInfo.new(0.4), {ImageTransparency = 1}):Play()
            DebugInfo("print", "ArbixTPGui hidden", "")
        end
    end
end)

local dragging = false
local dragInput, dragStart, startPos

TitleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = Frame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

TitleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        local delta = input.Position - dragStart
        local goal = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
        Frame:TweenPosition(goal, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.05, true)
    end
end)

DebugInfo("print", "ArbixTPGui initialization completed", "")
]]

-- Ejecutar directamente el scriptToLoad al iniciar
local success, errorMsg = pcall(function()
    local func = loadstring(scriptToLoad)
    if not func then
        error("Failed to compile scriptToLoad")
    end
    func()
end)
if not success then
    warn("[ArbixHub ERROR]: Failed to execute scriptToLoad: " .. tostring(errorMsg))
else
    print("[ArbixHub]: Successfully executed scriptToLoad")
end
